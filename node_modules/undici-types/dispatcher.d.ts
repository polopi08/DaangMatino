import { URL } from 'url'
import { Duplex, Readable, Writable } from 'stream'
import { EventEmitter } from 'events'
import { Blob } from 'buffer'
import { IncomingHttpHeaders } from './header'
import BodyReadable from './readable'
import { FormData } from './formdata'
import Errors from './errors'
import { Autocomplete } from './utility'

type AbortSignal = unknown

export default Dispatcher

export type UndiciHeaders = Record<string, string | string[]> | IncomingHttpHeaders | string[] | Iterable<[string, string | string[] | undefined]> | null


declare class Dispatcher extends EventEmitter {
  
  dispatch (options: Dispatcher.DispatchOptions, handler: Dispatcher.DispatchHandler): boolean
  
  connect<TOpaque = null>(options: Dispatcher.ConnectOptions<TOpaque>): Promise<Dispatcher.ConnectData<TOpaque>>
  connect<TOpaque = null>(options: Dispatcher.ConnectOptions<TOpaque>, callback: (err: Error | null, data: Dispatcher.ConnectData<TOpaque>) => void): void
  
  compose (dispatchers: Dispatcher.DispatcherComposeInterceptor[]): Dispatcher.ComposedDispatcher
  compose (...dispatchers: Dispatcher.DispatcherComposeInterceptor[]): Dispatcher.ComposedDispatcher
  
  request<TOpaque = null>(options: Dispatcher.RequestOptions<TOpaque>): Promise<Dispatcher.ResponseData<TOpaque>>
  request<TOpaque = null>(options: Dispatcher.RequestOptions<TOpaque>, callback: (err: Error | null, data: Dispatcher.ResponseData<TOpaque>) => void): void
  
  pipeline<TOpaque = null>(options: Dispatcher.PipelineOptions<TOpaque>, handler: Dispatcher.PipelineHandler<TOpaque>): Duplex
  
  stream<TOpaque = null>(options: Dispatcher.RequestOptions<TOpaque>, factory: Dispatcher.StreamFactory<TOpaque>): Promise<Dispatcher.StreamData<TOpaque>>
  stream<TOpaque = null>(options: Dispatcher.RequestOptions<TOpaque>, factory: Dispatcher.StreamFactory<TOpaque>, callback: (err: Error | null, data: Dispatcher.StreamData<TOpaque>) => void): void
  
  upgrade (options: Dispatcher.UpgradeOptions): Promise<Dispatcher.UpgradeData>
  upgrade (options: Dispatcher.UpgradeOptions, callback: (err: Error | null, data: Dispatcher.UpgradeData) => void): void
  
  close (): Promise<void>
  close (callback: () => void): void
  
  destroy (): Promise<void>
  destroy (err: Error | null): Promise<void>
  destroy (callback: () => void): void
  destroy (err: Error | null, callback: () => void): void

  on (eventName: 'connect', callback: (origin: URL, targets: readonly Dispatcher[]) => void): this
  on (eventName: 'disconnect', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this
  on (eventName: 'connectionError', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this
  on (eventName: 'drain', callback: (origin: URL) => void): this

  once (eventName: 'connect', callback: (origin: URL, targets: readonly Dispatcher[]) => void): this
  once (eventName: 'disconnect', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this
  once (eventName: 'connectionError', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this
  once (eventName: 'drain', callback: (origin: URL) => void): this

  off (eventName: 'connect', callback: (origin: URL, targets: readonly Dispatcher[]) => void): this
  off (eventName: 'disconnect', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this
  off (eventName: 'connectionError', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this
  off (eventName: 'drain', callback: (origin: URL) => void): this

  addListener (eventName: 'connect', callback: (origin: URL, targets: readonly Dispatcher[]) => void): this
  addListener (eventName: 'disconnect', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this
  addListener (eventName: 'connectionError', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this
  addListener (eventName: 'drain', callback: (origin: URL) => void): this

  removeListener (eventName: 'connect', callback: (origin: URL, targets: readonly Dispatcher[]) => void): this
  removeListener (eventName: 'disconnect', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this
  removeListener (eventName: 'connectionError', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this
  removeListener (eventName: 'drain', callback: (origin: URL) => void): this

  prependListener (eventName: 'connect', callback: (origin: URL, targets: readonly Dispatcher[]) => void): this
  prependListener (eventName: 'disconnect', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this
  prependListener (eventName: 'connectionError', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this
  prependListener (eventName: 'drain', callback: (origin: URL) => void): this

  prependOnceListener (eventName: 'connect', callback: (origin: URL, targets: readonly Dispatcher[]) => void): this
  prependOnceListener (eventName: 'disconnect', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this
  prependOnceListener (eventName: 'connectionError', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this
  prependOnceListener (eventName: 'drain', callback: (origin: URL) => void): this

  listeners (eventName: 'connect'): ((origin: URL, targets: readonly Dispatcher[]) => void)[]
  listeners (eventName: 'disconnect'): ((origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void)[]
  listeners (eventName: 'connectionError'): ((origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void)[]
  listeners (eventName: 'drain'): ((origin: URL) => void)[]

  rawListeners (eventName: 'connect'): ((origin: URL, targets: readonly Dispatcher[]) => void)[]
  rawListeners (eventName: 'disconnect'): ((origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void)[]
  rawListeners (eventName: 'connectionError'): ((origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void)[]
  rawListeners (eventName: 'drain'): ((origin: URL) => void)[]

  emit (eventName: 'connect', origin: URL, targets: readonly Dispatcher[]): boolean
  emit (eventName: 'disconnect', origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError): boolean
  emit (eventName: 'connectionError', origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError): boolean
  emit (eventName: 'drain', origin: URL): boolean
}

declare namespace Dispatcher {
  export interface ComposedDispatcher extends Dispatcher {}
  export type DispatcherComposeInterceptor = (dispatch: Dispatcher['dispatch']) => Dispatcher['dispatch']
  export interface DispatchOptions {
    origin?: string | URL;
    path: string;
    method: HttpMethod;
    
    body?: string | Buffer | Uint8Array | Readable | null | FormData;
    
    headers?: UndiciHeaders;
    
    query?: Record<string, any>;
    
    idempotent?: boolean;
    
    blocking?: boolean;
    
    upgrade?: boolean | string | null;
    
    headersTimeout?: number | null;
    
    bodyTimeout?: number | null;
    
    reset?: boolean;
    
    throwOnError?: boolean;
    
    expectContinue?: boolean;
  }
  export interface ConnectOptions<TOpaque = null> {
    origin: string | URL;
    path: string;
    
    headers?: UndiciHeaders;
    
    signal?: AbortSignal | EventEmitter | null;
    
    opaque?: TOpaque;
    
    maxRedirections?: number;
    
    redirectionLimitReached?: boolean;
    
    responseHeaders?: 'raw' | null;
  }
  export interface RequestOptions<TOpaque = null> extends DispatchOptions {
    
    opaque?: TOpaque;
    
    signal?: AbortSignal | EventEmitter | null;
    
    maxRedirections?: number;
    
    redirectionLimitReached?: boolean;
    
    onInfo?: (info: { statusCode: number, headers: Record<string, string | string[]> }) => void;
    
    responseHeaders?: 'raw' | null;
    
    highWaterMark?: number;
  }
  export interface PipelineOptions<TOpaque = null> extends RequestOptions<TOpaque> {
    
    objectMode?: boolean;
  }
  export interface UpgradeOptions {
    path: string;
    
    method?: string;
    
    headers?: UndiciHeaders;
    
    protocol?: string;
    
    signal?: AbortSignal | EventEmitter | null;
    
    maxRedirections?: number;
    
    redirectionLimitReached?: boolean;
    
    responseHeaders?: 'raw' | null;
  }
  export interface ConnectData<TOpaque = null> {
    statusCode: number;
    headers: IncomingHttpHeaders;
    socket: Duplex;
    opaque: TOpaque;
  }
  export interface ResponseData<TOpaque = null> {
    statusCode: number;
    headers: IncomingHttpHeaders;
    body: BodyReadable & BodyMixin;
    trailers: Record<string, string>;
    opaque: TOpaque;
    context: object;
  }
  export interface PipelineHandlerData<TOpaque = null> {
    statusCode: number;
    headers: IncomingHttpHeaders;
    opaque: TOpaque;
    body: BodyReadable;
    context: object;
  }
  export interface StreamData<TOpaque = null> {
    opaque: TOpaque;
    trailers: Record<string, string>;
  }
  export interface UpgradeData<TOpaque = null> {
    headers: IncomingHttpHeaders;
    socket: Duplex;
    opaque: TOpaque;
  }
  export interface StreamFactoryData<TOpaque = null> {
    statusCode: number;
    headers: IncomingHttpHeaders;
    opaque: TOpaque;
    context: object;
  }
  export type StreamFactory<TOpaque = null> = (data: StreamFactoryData<TOpaque>) => Writable

  export interface DispatchController {
    get aborted () : boolean
    get paused () : boolean
    get reason () : Error | null
    abort (reason: Error): void
    pause(): void
    resume(): void
  }

  export interface DispatchHandler {
    onRequestStart?(controller: DispatchController, context: any): void;
    onRequestUpgrade?(controller: DispatchController, statusCode: number, headers: IncomingHttpHeaders, socket: Duplex): void;
    onResponseStart?(controller: DispatchController, statusCode: number, headers: IncomingHttpHeaders, statusMessage?: string): void;
    onResponseData?(controller: DispatchController, chunk: Buffer): void;
    onResponseEnd?(controller: DispatchController, trailers: IncomingHttpHeaders): void;
    onResponseError?(controller: DispatchController, error: Error): void;

    
    
    onConnect?(abort: (err?: Error) => void): void;
    
    
    onError?(err: Error): void;
    
    
    onUpgrade?(statusCode: number, headers: Buffer[] | string[] | null, socket: Duplex): void;
    
    
    onResponseStarted?(): void;
    
    
    onHeaders?(statusCode: number, headers: Buffer[], resume: () => void, statusText: string): boolean;
    
    
    onData?(chunk: Buffer): boolean;
    
    
    onComplete?(trailers: string[] | null): void;
    
    
    onBodySent?(chunkSize: number, totalBytesSent: number): void;
  }
  export type PipelineHandler<TOpaque = null> = (data: PipelineHandlerData<TOpaque>) => Readable
  export type HttpMethod = Autocomplete<'GET' | 'HEAD' | 'POST' | 'PUT' | 'DELETE' | 'CONNECT' | 'OPTIONS' | 'TRACE' | 'PATCH'>

  /**
   * @link https:
   */
  interface BodyMixin {
    readonly body?: never;
    readonly bodyUsed: boolean;
    arrayBuffer(): Promise<ArrayBuffer>;
    blob(): Promise<Blob>;
    bytes(): Promise<Uint8Array>;
    formData(): Promise<never>;
    json(): Promise<unknown>;
    text(): Promise<string>;
  }

  export interface DispatchInterceptor {
    (dispatch: Dispatcher['dispatch']): Dispatcher['dispatch']
  }
}
