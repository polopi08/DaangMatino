import { IncomingHttpHeaders } from './header'
import Dispatcher from './dispatcher'
import { BodyInit, Headers } from './fetch'


declare class MockScope<TData extends object = object> {
  constructor (mockDispatch: MockInterceptor.MockDispatch<TData>)
  
  delay (waitInMs: number): MockScope<TData>
  
  persist (): MockScope<TData>
  
  times (repeatTimes: number): MockScope<TData>
}


declare class MockInterceptor {
  constructor (options: MockInterceptor.Options, mockDispatches: MockInterceptor.MockDispatch[])
  
  reply<TData extends object = object>(replyOptionsCallback: MockInterceptor.MockReplyOptionsCallback<TData>): MockScope<TData>
  reply<TData extends object = object>(
    statusCode: number,
    data?: TData | Buffer | string | MockInterceptor.MockResponseDataHandler<TData>,
    responseOptions?: MockInterceptor.MockResponseOptions
  ): MockScope<TData>
  
  replyWithError<TError extends Error = Error>(error: TError): MockScope
  
  defaultReplyHeaders (headers: IncomingHttpHeaders): MockInterceptor
  
  defaultReplyTrailers (trailers: Record<string, string>): MockInterceptor
  
  replyContentLength (): MockInterceptor
}

declare namespace MockInterceptor {
  
  export interface Options {
    
    path: string | RegExp | ((path: string) => boolean);
    
    method?: string | RegExp | ((method: string) => boolean);
    
    body?: string | RegExp | ((body: string) => boolean);
    
    headers?: Record<string, string | RegExp | ((body: string) => boolean)> | ((headers: Record<string, string>) => boolean);
    
    query?: Record<string, any>;
  }
  export interface MockDispatch<TData extends object = object, TError extends Error = Error> extends Options {
    times: number | null;
    persist: boolean;
    consumed: boolean;
    data: MockDispatchData<TData, TError>;
  }
  export interface MockDispatchData<TData extends object = object, TError extends Error = Error> extends MockResponseOptions {
    error: TError | null;
    statusCode?: number;
    data?: TData | string;
  }
  export interface MockResponseOptions {
    headers?: IncomingHttpHeaders;
    trailers?: Record<string, string>;
  }

  export interface MockResponseCallbackOptions {
    path: string;
    method: string;
    headers?: Headers | Record<string, string>;
    origin?: string;
    body?: BodyInit | Dispatcher.DispatchOptions['body'] | null;
    maxRedirections?: number;
  }

  export type MockResponseDataHandler<TData extends object = object> = (
    opts: MockResponseCallbackOptions
  ) => TData | Buffer | string

  export type MockReplyOptionsCallback<TData extends object = object> = (
    opts: MockResponseCallbackOptions
  ) => { statusCode: number, data?: TData | Buffer | string, responseOptions?: MockResponseOptions }
}

interface Interceptable extends Dispatcher {
  
  intercept(options: MockInterceptor.Options): MockInterceptor;
}

export {
  Interceptable,
  MockInterceptor,
  MockScope
}
