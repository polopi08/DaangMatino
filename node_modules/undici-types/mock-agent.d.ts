import Agent from './agent'
import Dispatcher from './dispatcher'
import { Interceptable, MockInterceptor } from './mock-interceptor'
import MockDispatch = MockInterceptor.MockDispatch
import { MockCallHistory } from './mock-call-history'

export default MockAgent

interface PendingInterceptor extends MockDispatch {
  origin: string;
}


declare class MockAgent<TMockAgentOptions extends MockAgent.Options = MockAgent.Options> extends Dispatcher {
  constructor (options?: TMockAgentOptions)
  
  get<TInterceptable extends Interceptable>(origin: string): TInterceptable
  get<TInterceptable extends Interceptable>(origin: RegExp): TInterceptable
  get<TInterceptable extends Interceptable>(origin: ((origin: string) => boolean)): TInterceptable
  
  dispatch (options: Agent.DispatchOptions, handler: Dispatcher.DispatchHandler): boolean
  
  close (): Promise<void>
  
  deactivate (): void
  
  activate (): void
  
  enableNetConnect (): void
  enableNetConnect (host: string): void
  enableNetConnect (host: RegExp): void
  enableNetConnect (host: ((host: string) => boolean)): void
  
  disableNetConnect (): void
  
  getCallHistory (): MockCallHistory | undefined
  
  clearCallHistory (): void
  
  enableCallHistory (): this
  
  disableCallHistory (): this
  pendingInterceptors (): PendingInterceptor[]
  assertNoPendingInterceptors (options?: {
    pendingInterceptorsFormatter?: PendingInterceptorsFormatter;
  }): void
}

interface PendingInterceptorsFormatter {
  format(pendingInterceptors: readonly PendingInterceptor[]): string;
}

declare namespace MockAgent {
  
  export interface Options extends Agent.Options {
    
    agent?: Dispatcher;

    
    ignoreTrailingSlash?: boolean;

    
    enableCallHistory?: boolean
  }
}
