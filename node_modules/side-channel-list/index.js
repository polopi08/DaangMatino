'use strict';

var inspect = require('object-inspect');

var $TypeError = require('es-errors/type');

/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.
* By doing so, all the recently used nodes can be accessed relatively quickly.
*/


var listGetNode = function (list, key, isDelete) {
	
	var prev = list;
	
	var curr;
	
	for (; (curr = prev.next) != null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			if (!isDelete) {
				
				curr.next =  (list.next);
				list.next = curr; 
			}
			return curr;
		}
	}
};


var listGet = function (objects, key) {
	if (!objects) {
		return void undefined;
	}
	var node = listGetNode(objects, key);
	return node && node.value;
};

var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		
		objects.next =  ({ 
			key: key,
			next: objects.next,
			value: value
		});
	}
};

var listHas = function (objects, key) {
	if (!objects) {
		return false;
	}
	return !!listGetNode(objects, key);
};


var listDelete = function (objects, key) {
	if (objects) {
		return listGetNode(objects, key, true);
	}
};


module.exports = function getSideChannelList() {
	
	
	

	 var $o;

	
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		'delete': function (key) {
			var root = $o && $o.next;
			var deletedNode = listDelete($o, key);
			if (deletedNode && root && root === deletedNode) {
				$o = void undefined;
			}
			return !!deletedNode;
		},
		get: function (key) {
			return listGet($o, key);
		},
		has: function (key) {
			return listHas($o, key);
		},
		set: function (key, value) {
			if (!$o) {
				
				$o = {
					next: void undefined
				};
			}
			
			listSet( ($o), key, value);
		}
	};
	
	return channel;
};
