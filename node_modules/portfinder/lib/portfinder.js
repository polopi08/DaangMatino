/*
 * portfinder.js: A simple tool to find an open port on the current machine.
 *
 * (C) 2011, Charlie Robbins
 *
 */

"use strict";

const fs = require('fs'),
      os = require('os'),
      net = require('net'),
      path = require('path'),
      _async = require('async'),
      debug = require('debug');

const debugTestPort = debug('portfinder:testPort'),
      debugGetPort = debug('portfinder:getPort'),
      debugDefaultHosts = debug('portfinder:defaultHosts');

const internals = {};

internals.testPort = function(options, callback) {
  if (!callback) {
    callback = options;
    options = {};
  }

  options.server = options.server  || net.createServer(function () {
    
    
    
  });

  debugTestPort("entered testPort(): trying", options.host, "port", options.port);

  function onListen () {
    debugTestPort("done w/ testPort(): OK", options.host, "port", options.port);

    options.server.removeListener('error', onError);
    options.server.close(function () {
      debugTestPort("done w/ testPort(): Server closed", options.host, "port", options.port);
      callback(null, options.port);
    });
  }

  function onError (err) {
    debugTestPort("done w/ testPort(): failed", options.host, "w/ port", options.port, "with error", err.code);

    options.server.removeListener('listening', onListen);

    if (!(err.code == 'EADDRINUSE' || err.code == 'EACCES')) {
      return callback(err);
    }

    const nextPort = exports.nextPort(options.port);

    if (nextPort > exports.highestPort) {
      return callback(new Error('No open ports available'));
    }

    internals.testPort({
      port: nextPort,
      host: options.host,
      server: options.server
    }, callback);
  }

  options.server.once('error', onError);
  options.server.once('listening', onListen);

  if (options.host) {
    options.server.listen(options.port, options.host);
  } else {
    /*
      Judgement of service without host
      example:
        express().listen(options.port)
    */
    options.server.listen(options.port);
  }
};





exports.basePort = 8000;





exports.setBasePort = function (port) {
  exports.basePort = port;
}





exports.highestPort = 65535;





exports.setHighestPort = function (port) {
  exports.highestPort = port;
}





exports.basePath = '/tmp/portfinder'





exports.setBasePath = function (path) {
  exports.basePath = path;
};

internals.getPort = function (options, callback) {
  options.port   = Number(options.port) || Number(options.startPort) || Number(exports.basePort);
  options.host   = options.host    || null;
  options.stopPort = Number(options.stopPort) || Number(exports.highestPort);

  if (!options.startPort) {
    options.startPort = options.port;
    if (options.startPort < 0) {
      return callback(Error(`Provided options.port(${options.port}) is less than 0, which are cannot be bound.`));
    }
    if (options.stopPort < options.startPort) {
      return callback(Error(`Provided options.stopPort(${options.stopPort}) is less than options.port(${options.startPort})`));
    }
  }

  if (options.host && exports._defaultHosts.indexOf(options.host) === -1) {
    exports._defaultHosts.push(options.host)
  }

  const openPorts = [];
  let currentHost;
  return _async.eachSeries(exports._defaultHosts, function(host, next) {
    debugGetPort("in eachSeries() iteration callback: host is", host);

    return internals.testPort({ host: host, port: options.port }, function(err, port) {
      if (err) {
        debugGetPort("in eachSeries() iteration callback testPort() callback", "with an err:", err.code);
        currentHost = host;
        return next(err);
      } else {
        debugGetPort("in eachSeries() iteration callback testPort() callback",
                    "with a success for port", port);
        openPorts.push(port);
        return next();
      }
    });
  }, function(err) {

    if (err) {
      debugGetPort("in eachSeries() result callback: err is", err);
      
      
      if (err.code === 'EADDRNOTAVAIL' || err.code === 'EINVAL') {
        if (options.host === currentHost) {
          
          
          
          
          
          const msg = 'Provided host ' + options.host + ' could NOT be bound. Please provide a different host address or hostname';
          return callback(Error(msg));
        } else {
          const idx = exports._defaultHosts.indexOf(currentHost);
          exports._defaultHosts.splice(idx, 1);
          return internals.getPort(options, callback);
        }
      } else {
        
        return callback(err);
      }
    }

    
    openPorts.sort(function(a, b) {
      return a - b;
    });

    debugGetPort("in eachSeries() result callback: openPorts is", openPorts);

    if (openPorts[0] === openPorts[openPorts.length-1]) {
      
      if(openPorts[0] <= options.stopPort) {
        return callback(null, openPorts[0]);
      }
      else {
        const msg = 'No open ports found in between '+ options.startPort + ' and ' + options.stopPort;
        return callback(Error(msg));
      }
    } else {
      
      return internals.getPort({ port: openPorts.pop(), host: options.host, startPort: options.startPort, stopPort: options.stopPort }, callback);
    }

  });
};






exports.getPort = function (options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  options = options || {};

  if (!callback) {
    return new Promise(function (resolve, reject) {
      internals.getPort(options, function (err, port) {
        if (err) {
          return reject(err);
        }
        resolve(port);
      });
    });
  } else {
    internals.getPort(options, callback);
  }
};






exports.getPortPromise = exports.getPort;

internals.getPorts = function (count, options, callback) {
  let lastPort = null;
  _async.timesSeries(count, function(index, asyncCallback) {
    if (lastPort) {
      options.port = exports.nextPort(lastPort);
    }

    internals.getPort(options, function (err, port) {
      if (err) {
        asyncCallback(err);
      } else {
        lastPort = port;
        asyncCallback(null, port);
      }
    });
  }, callback);
};








exports.getPorts = function (count, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  options = options || {};

  if (!callback) {
    return new Promise(function(resolve, reject) {
      internals.getPorts(count, options, function(err, ports) {
        if (err) {
          return reject(err);
        }
        resolve(ports);
      });
    });
  } else {
    internals.getPorts(count, options, callback);
  }
};







exports.getPortsPromise = exports.getPorts;

internals.getSocket = function (options, callback) {
  options.mod  = options.mod    || parseInt(755, 8);
  options.path = options.path   || exports.basePath + '.sock';

  
  
  
  function testSocket () {
    fs.stat(options.path, function (err) {
      
      
      
      
      if (err) {
        if (err.code == 'ENOENT') {
          callback(null, options.path);
        }
        else {
          callback(err);
        }
      }
      else {
        
        
        
        
        options.path = exports.nextSocket(options.path);
        internals.getSocket(options, callback);
      }
    });
  }

  
  
  
  
  function createAndTestSocket (dir) {
    fs.mkdir(dir, { mode: options.mod, recursive: true }, function (err) {
      if (err) {
        return callback(err);
      }

      options.exists = true;
      testSocket();
    });
  }

  
  
  
  
  
  
  function checkAndTestSocket () {
    const dir = path.dirname(options.path);

    fs.stat(dir, function (err, stats) {
      if (err || !stats.isDirectory()) {
        return createAndTestSocket(dir);
      }

      options.exists = true;
      testSocket();
    });
  }

  
  
  
  
  
  return options.exists
    ? testSocket()
    : checkAndTestSocket();
};








exports.getSocket = function (options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  options = options || {};

  if (!callback) {
    return new Promise(function (resolve, reject) {
      internals.getSocket(options, function (err, socketPath) {
        if (err) {
          return reject(err);
        }
        resolve(socketPath);
      });
    });
  } else {
    internals.getSocket(options, callback);
  }
}

exports.getSocketPromise = exports.getSocket;







exports.nextPort = function (port) {
  return port + 1;
};







exports.nextSocket = function (socketPath) {
  const dir = path.dirname(socketPath),
        name = path.basename(socketPath, '.sock'),
        match = name.match(/^([a-zA-z]+)(\d*)$/i),
        base = match[1];
  let index = parseInt(match[2]);
  if (isNaN(index)) {
    index = 0;
  }

  index += 1;
  return path.join(dir, base + index + '.sock');
};

/**
 * @desc List of internal hostnames provided by your machine. A user
 *       provided hostname may also be provided when calling portfinder.getPort,
 *       which would then be added to the default hosts we lookup and return here.
 *
 * @return {array}
 *
 * Long Form Explantion:
 *
 *    - Input: (os.networkInterfaces() w/ MacOS 10.11.5+ and running a VM)
 *
 *        { lo0:
 *         [ { address: '::1',
 *             netmask: 'ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff',
 *             family: 'IPv6',
 *             mac: '00:00:00:00:00:00',
 *             scopeid: 0,
 *             internal: true },
 *           { address: '127.0.0.1',
 *             netmask: '255.0.0.0',
 *             family: 'IPv4',
 *             mac: '00:00:00:00:00:00',
 *             internal: true },
 *           { address: 'fe80::1',
 *             netmask: 'ffff:ffff:ffff:ffff::',
 *             family: 'IPv6',
 *             mac: '00:00:00:00:00:00',
 *             scopeid: 1,
 *             internal: true } ],
 *        en0:
 *         [ { address: 'fe80::a299:9bff:fe17:766d',
 *             netmask: 'ffff:ffff:ffff:ffff::',
 *             family: 'IPv6',
 *             mac: 'a0:99:9b:17:76:6d',
 *             scopeid: 4,
 *             internal: false },
 *           { address: '10.0.1.22',
 *             netmask: '255.255.255.0',
 *             family: 'IPv4',
 *             mac: 'a0:99:9b:17:76:6d',
 *             internal: false } ],
 *        awdl0:
 *         [ { address: 'fe80::48a8:37ff:fe34:aaef',
 *             netmask: 'ffff:ffff:ffff:ffff::',
 *             family: 'IPv6',
 *             mac: '4a:a8:37:34:aa:ef',
 *             scopeid: 8,
 *             internal: false } ],
 *        vnic0:
 *         [ { address: '10.211.55.2',
 *             netmask: '255.255.255.0',
 *             family: 'IPv4',
 *             mac: '00:1c:42:00:00:08',
 *             internal: false } ],
 *        vnic1:
 *         [ { address: '10.37.129.2',
 *             netmask: '255.255.255.0',
 *             family: 'IPv4',
 *             mac: '00:1c:42:00:00:09',
 *             internal: false } ] }
 *
 *    - Output:
 *
 *         [
 *          '0.0.0.0',
 *          '::1',
 *          '127.0.0.1',
 *          'fe80::1',
 *          '10.0.1.22',
 *          'fe80::48a8:37ff:fe34:aaef',
 *          '10.211.55.2',
 *          '10.37.129.2'
 *         ]
 *
 *     Note we export this so we can use it in our tests, otherwise this API is private
 */
exports._defaultHosts = (function() {
  let interfaces = {};
  try{
    interfaces = os.networkInterfaces();
  }
  catch(e) {
    
    
    
    
    
    
    
    
    
    if (e.syscall === 'uv_interface_addresses') {
      
      
    } else {
      throw e;
    }
  }

  const interfaceNames = Object.keys(interfaces),
        hiddenButImportantHost = '0.0.0.0', 
        results = [hiddenButImportantHost];
  for (let i = 0; i < interfaceNames.length; i++) {
    const _interface = interfaces[interfaceNames[i]];
    for (let j = 0; j < _interface.length; j++) {
      const curr = _interface[j];
      results.push(curr.address);
    }
  }

  
  results.push(null);

  debugDefaultHosts("exports._defaultHosts is: %o", results);

  return results;
}());
